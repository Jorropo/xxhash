//go:build go1.17
// +build go1.17

package xxhash

import "math/bits"

// Generated by gen/slide.go. DO NOT EDIT.

const slideLength = 127

// Handles length 0-127 bytes using sum slides.
func slide(b []byte) uint64 {
	// This function use sum slides, theses are straight unrolled pieces of code which compute hashes, with middle jumps.
	// Each do not contain any conditions to make them trivial for the CPU to parse and never cause any pipeline flushes after the first jump table.
	// We need 32 different slides to cover each offset into the 32 block size. The trailing 32 bytes are handled by their own slides which are shared and reused by the higher slides.
	// The trailing 32 bytes slides are reused for each offset. The CPUs we care about can always correctly read unconditional jumps without causing a pipeline flush.

	// This function is written more like an optimized assembly routine, except we trick the compiler into generating good code by generating the slide ourself.
	// Using the go compiler make the call overhead cheaper since it will use the unstable ABIInternal passing through registers.
	// They are also extremely effective when hashing multiple values of the same size back to back.
	// Assumptions of this strategy:
	// - All the state except b's array will be correctly register allocated.
	//   It probably generate unnecessary MOVs but the critical path includes LAT3 multiplies for each block, so there is plenty of time to dispatch renames.
	// - The compiler is basic block based and will do a good enough job at layout. This is true for some the go compiler, llvm and some of gcc.
	//   This means I make very liberal use of goto, they shouldn't be red as JMPs but abstract basic blocks links.
	// - The compiler has some SSA passes.
	//   This is used for all the b_* tricks.
	// - We can't trust the compiler to inline anything (except intrinsics).

	// Setup variables here since go doesn't want use to do dangerous gotos.
	v1 := prime1
	v1 += prime2
	v2 := prime2
	v3 := uint64(0)
	v4 := prime1
	v4 = -v4
	h := prime5
	n := uint64(len(b))

	// The go compiler has multiple oversight in the propragation of proofs through Phi nodes. Using array pointers is a very unsubtle hint and compiles to nothing.
	// Because we assume the compiler has some low level SSA passes this is otherwise free.
	var b_0 *[0]byte
	var b_1 *[1]byte
	var b_2 *[2]byte
	var b_3 *[3]byte
	var b_4 *[4]byte
	var b_5 *[5]byte
	var b_6 *[6]byte
	var b_7 *[7]byte
	var b_8 *[8]byte
	var b_9 *[9]byte
	var b_10 *[10]byte
	var b_11 *[11]byte
	var b_12 *[12]byte
	var b_13 *[13]byte
	var b_14 *[14]byte
	var b_15 *[15]byte
	var b_16 *[16]byte
	var b_17 *[17]byte
	var b_18 *[18]byte
	var b_19 *[19]byte
	var b_20 *[20]byte
	var b_21 *[21]byte
	var b_22 *[22]byte
	var b_23 *[23]byte
	var b_24 *[24]byte
	var b_25 *[25]byte
	var b_26 *[26]byte
	var b_27 *[27]byte
	var b_28 *[28]byte
	var b_29 *[29]byte
	var b_30 *[30]byte
	var b_31 *[31]byte
	var b_32 *[32]byte
	var b_33 *[33]byte
	var b_34 *[34]byte
	var b_35 *[35]byte
	var b_36 *[36]byte
	var b_37 *[37]byte
	var b_38 *[38]byte
	var b_39 *[39]byte
	var b_40 *[40]byte
	var b_41 *[41]byte
	var b_42 *[42]byte
	var b_43 *[43]byte
	var b_44 *[44]byte
	var b_45 *[45]byte
	var b_46 *[46]byte
	var b_47 *[47]byte
	var b_48 *[48]byte
	var b_49 *[49]byte
	var b_50 *[50]byte
	var b_51 *[51]byte
	var b_52 *[52]byte
	var b_53 *[53]byte
	var b_54 *[54]byte
	var b_55 *[55]byte
	var b_56 *[56]byte
	var b_57 *[57]byte
	var b_58 *[58]byte
	var b_59 *[59]byte
	var b_60 *[60]byte
	var b_61 *[61]byte
	var b_62 *[62]byte
	var b_63 *[63]byte
	var b_64 *[64]byte
	var b_65 *[65]byte
	var b_66 *[66]byte
	var b_67 *[67]byte
	var b_68 *[68]byte
	var b_69 *[69]byte
	var b_70 *[70]byte
	var b_71 *[71]byte
	var b_72 *[72]byte
	var b_73 *[73]byte
	var b_74 *[74]byte
	var b_75 *[75]byte
	var b_76 *[76]byte
	var b_77 *[77]byte
	var b_78 *[78]byte
	var b_79 *[79]byte
	var b_80 *[80]byte
	var b_81 *[81]byte
	var b_82 *[82]byte
	var b_83 *[83]byte
	var b_84 *[84]byte
	var b_85 *[85]byte
	var b_86 *[86]byte
	var b_87 *[87]byte
	var b_88 *[88]byte
	var b_89 *[89]byte
	var b_90 *[90]byte
	var b_91 *[91]byte
	var b_92 *[92]byte
	var b_93 *[93]byte
	var b_94 *[94]byte
	var b_95 *[95]byte
	var b_96 *[96]byte
	var b_97 *[97]byte
	var b_98 *[98]byte
	var b_99 *[99]byte
	var b_100 *[100]byte
	var b_101 *[101]byte
	var b_102 *[102]byte
	var b_103 *[103]byte
	var b_104 *[104]byte
	var b_105 *[105]byte
	var b_106 *[106]byte
	var b_107 *[107]byte
	var b_108 *[108]byte
	var b_109 *[109]byte
	var b_110 *[110]byte
	var b_111 *[111]byte
	var b_112 *[112]byte
	var b_113 *[113]byte
	var b_114 *[114]byte
	var b_115 *[115]byte
	var b_116 *[116]byte
	var b_117 *[117]byte
	var b_118 *[118]byte
	var b_119 *[119]byte
	var b_120 *[120]byte
	var b_121 *[121]byte
	var b_122 *[122]byte
	var b_123 *[123]byte
	var b_124 *[124]byte
	var b_125 *[125]byte
	var b_126 *[126]byte
	var b_127 *[127]byte

	// Jump table to various positions in the slide, this setups proofs for bounds checks.
	// From then on it need to make sure to maintain constance in the length of b.
	switch len(b) {
	case 0:
		// Handle this appart because it can be completely folded.
		h += n
		h ^= h >> 33
		h *= prime2
		h ^= h >> 29
		h *= prime3
		h ^= h >> 32
		return h
	case 1:
		b_1 = (*[1]byte)(b)
		goto sz_1
	case 2:
		b_2 = (*[2]byte)(b)
		goto sz_2
	case 3:
		b_3 = (*[3]byte)(b)
		goto sz_3
	case 4:
		b_4 = (*[4]byte)(b)
		goto sz_4
	case 5:
		b_5 = (*[5]byte)(b)
		goto sz_5
	case 6:
		b_6 = (*[6]byte)(b)
		goto sz_6
	case 7:
		b_7 = (*[7]byte)(b)
		goto sz_7
	case 8:
		b_8 = (*[8]byte)(b)
		goto sz_8
	case 9:
		b_9 = (*[9]byte)(b)
		goto sz_9
	case 10:
		b_10 = (*[10]byte)(b)
		goto sz_10
	case 11:
		b_11 = (*[11]byte)(b)
		goto sz_11
	case 12:
		b_12 = (*[12]byte)(b)
		goto sz_12
	case 13:
		b_13 = (*[13]byte)(b)
		goto sz_13
	case 14:
		b_14 = (*[14]byte)(b)
		goto sz_14
	case 15:
		b_15 = (*[15]byte)(b)
		goto sz_15
	case 16:
		b_16 = (*[16]byte)(b)
		goto sz_16
	case 17:
		b_17 = (*[17]byte)(b)
		goto sz_17
	case 18:
		b_18 = (*[18]byte)(b)
		goto sz_18
	case 19:
		b_19 = (*[19]byte)(b)
		goto sz_19
	case 20:
		b_20 = (*[20]byte)(b)
		goto sz_20
	case 21:
		b_21 = (*[21]byte)(b)
		goto sz_21
	case 22:
		b_22 = (*[22]byte)(b)
		goto sz_22
	case 23:
		b_23 = (*[23]byte)(b)
		goto sz_23
	case 24:
		b_24 = (*[24]byte)(b)
		goto sz_24
	case 25:
		b_25 = (*[25]byte)(b)
		goto sz_25
	case 26:
		b_26 = (*[26]byte)(b)
		goto sz_26
	case 27:
		b_27 = (*[27]byte)(b)
		goto sz_27
	case 28:
		b_28 = (*[28]byte)(b)
		goto sz_28
	case 29:
		b_29 = (*[29]byte)(b)
		goto sz_29
	case 30:
		b_30 = (*[30]byte)(b)
		goto sz_30
	case 31:
		b_31 = (*[31]byte)(b)
		goto sz_31
	case 32:
		b_32 = (*[32]byte)(b)
		goto sz_32
	case 33:
		b_33 = (*[33]byte)(b)
		goto sz_33
	case 34:
		b_34 = (*[34]byte)(b)
		goto sz_34
	case 35:
		b_35 = (*[35]byte)(b)
		goto sz_35
	case 36:
		b_36 = (*[36]byte)(b)
		goto sz_36
	case 37:
		b_37 = (*[37]byte)(b)
		goto sz_37
	case 38:
		b_38 = (*[38]byte)(b)
		goto sz_38
	case 39:
		b_39 = (*[39]byte)(b)
		goto sz_39
	case 40:
		b_40 = (*[40]byte)(b)
		goto sz_40
	case 41:
		b_41 = (*[41]byte)(b)
		goto sz_41
	case 42:
		b_42 = (*[42]byte)(b)
		goto sz_42
	case 43:
		b_43 = (*[43]byte)(b)
		goto sz_43
	case 44:
		b_44 = (*[44]byte)(b)
		goto sz_44
	case 45:
		b_45 = (*[45]byte)(b)
		goto sz_45
	case 46:
		b_46 = (*[46]byte)(b)
		goto sz_46
	case 47:
		b_47 = (*[47]byte)(b)
		goto sz_47
	case 48:
		b_48 = (*[48]byte)(b)
		goto sz_48
	case 49:
		b_49 = (*[49]byte)(b)
		goto sz_49
	case 50:
		b_50 = (*[50]byte)(b)
		goto sz_50
	case 51:
		b_51 = (*[51]byte)(b)
		goto sz_51
	case 52:
		b_52 = (*[52]byte)(b)
		goto sz_52
	case 53:
		b_53 = (*[53]byte)(b)
		goto sz_53
	case 54:
		b_54 = (*[54]byte)(b)
		goto sz_54
	case 55:
		b_55 = (*[55]byte)(b)
		goto sz_55
	case 56:
		b_56 = (*[56]byte)(b)
		goto sz_56
	case 57:
		b_57 = (*[57]byte)(b)
		goto sz_57
	case 58:
		b_58 = (*[58]byte)(b)
		goto sz_58
	case 59:
		b_59 = (*[59]byte)(b)
		goto sz_59
	case 60:
		b_60 = (*[60]byte)(b)
		goto sz_60
	case 61:
		b_61 = (*[61]byte)(b)
		goto sz_61
	case 62:
		b_62 = (*[62]byte)(b)
		goto sz_62
	case 63:
		b_63 = (*[63]byte)(b)
		goto sz_63
	case 64:
		b_64 = (*[64]byte)(b)
		goto sz_64
	case 65:
		b_65 = (*[65]byte)(b)
		goto sz_65
	case 66:
		b_66 = (*[66]byte)(b)
		goto sz_66
	case 67:
		b_67 = (*[67]byte)(b)
		goto sz_67
	case 68:
		b_68 = (*[68]byte)(b)
		goto sz_68
	case 69:
		b_69 = (*[69]byte)(b)
		goto sz_69
	case 70:
		b_70 = (*[70]byte)(b)
		goto sz_70
	case 71:
		b_71 = (*[71]byte)(b)
		goto sz_71
	case 72:
		b_72 = (*[72]byte)(b)
		goto sz_72
	case 73:
		b_73 = (*[73]byte)(b)
		goto sz_73
	case 74:
		b_74 = (*[74]byte)(b)
		goto sz_74
	case 75:
		b_75 = (*[75]byte)(b)
		goto sz_75
	case 76:
		b_76 = (*[76]byte)(b)
		goto sz_76
	case 77:
		b_77 = (*[77]byte)(b)
		goto sz_77
	case 78:
		b_78 = (*[78]byte)(b)
		goto sz_78
	case 79:
		b_79 = (*[79]byte)(b)
		goto sz_79
	case 80:
		b_80 = (*[80]byte)(b)
		goto sz_80
	case 81:
		b_81 = (*[81]byte)(b)
		goto sz_81
	case 82:
		b_82 = (*[82]byte)(b)
		goto sz_82
	case 83:
		b_83 = (*[83]byte)(b)
		goto sz_83
	case 84:
		b_84 = (*[84]byte)(b)
		goto sz_84
	case 85:
		b_85 = (*[85]byte)(b)
		goto sz_85
	case 86:
		b_86 = (*[86]byte)(b)
		goto sz_86
	case 87:
		b_87 = (*[87]byte)(b)
		goto sz_87
	case 88:
		b_88 = (*[88]byte)(b)
		goto sz_88
	case 89:
		b_89 = (*[89]byte)(b)
		goto sz_89
	case 90:
		b_90 = (*[90]byte)(b)
		goto sz_90
	case 91:
		b_91 = (*[91]byte)(b)
		goto sz_91
	case 92:
		b_92 = (*[92]byte)(b)
		goto sz_92
	case 93:
		b_93 = (*[93]byte)(b)
		goto sz_93
	case 94:
		b_94 = (*[94]byte)(b)
		goto sz_94
	case 95:
		b_95 = (*[95]byte)(b)
		goto sz_95
	case 96:
		b_96 = (*[96]byte)(b)
		goto sz_96
	case 97:
		b_97 = (*[97]byte)(b)
		goto sz_97
	case 98:
		b_98 = (*[98]byte)(b)
		goto sz_98
	case 99:
		b_99 = (*[99]byte)(b)
		goto sz_99
	case 100:
		b_100 = (*[100]byte)(b)
		goto sz_100
	case 101:
		b_101 = (*[101]byte)(b)
		goto sz_101
	case 102:
		b_102 = (*[102]byte)(b)
		goto sz_102
	case 103:
		b_103 = (*[103]byte)(b)
		goto sz_103
	case 104:
		b_104 = (*[104]byte)(b)
		goto sz_104
	case 105:
		b_105 = (*[105]byte)(b)
		goto sz_105
	case 106:
		b_106 = (*[106]byte)(b)
		goto sz_106
	case 107:
		b_107 = (*[107]byte)(b)
		goto sz_107
	case 108:
		b_108 = (*[108]byte)(b)
		goto sz_108
	case 109:
		b_109 = (*[109]byte)(b)
		goto sz_109
	case 110:
		b_110 = (*[110]byte)(b)
		goto sz_110
	case 111:
		b_111 = (*[111]byte)(b)
		goto sz_111
	case 112:
		b_112 = (*[112]byte)(b)
		goto sz_112
	case 113:
		b_113 = (*[113]byte)(b)
		goto sz_113
	case 114:
		b_114 = (*[114]byte)(b)
		goto sz_114
	case 115:
		b_115 = (*[115]byte)(b)
		goto sz_115
	case 116:
		b_116 = (*[116]byte)(b)
		goto sz_116
	case 117:
		b_117 = (*[117]byte)(b)
		goto sz_117
	case 118:
		b_118 = (*[118]byte)(b)
		goto sz_118
	case 119:
		b_119 = (*[119]byte)(b)
		goto sz_119
	case 120:
		b_120 = (*[120]byte)(b)
		goto sz_120
	case 121:
		b_121 = (*[121]byte)(b)
		goto sz_121
	case 122:
		b_122 = (*[122]byte)(b)
		goto sz_122
	case 123:
		b_123 = (*[123]byte)(b)
		goto sz_123
	case 124:
		b_124 = (*[124]byte)(b)
		goto sz_124
	case 125:
		b_125 = (*[125]byte)(b)
		goto sz_125
	case 126:
		b_126 = (*[126]byte)(b)
		goto sz_126
	case 127:
		b_127 = (*[127]byte)(b)
		goto sz_127
	default:
		panic("unreachable; slide overflow")
	}

	// Theses are the main slides, they handle 32 bytes 4 × 8 bytes at a time using ILP.
sz_127:
	{
		b := b_127[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_95 = (*[95]byte)(b_127[32:])
	}

sz_95:
	{
		b := b_95[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_63 = (*[63]byte)(b_95[32:])
	}

sz_63:
	{
		b := b_63[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_31 = (*[31]byte)(b_63[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_31:
	h += n
	goto sz_31l

sz_126:
	{
		b := b_126[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_94 = (*[94]byte)(b_126[32:])
	}

sz_94:
	{
		b := b_94[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_62 = (*[62]byte)(b_94[32:])
	}

sz_62:
	{
		b := b_62[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_30 = (*[30]byte)(b_62[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_30:
	h += n
	goto sz_30l

sz_125:
	{
		b := b_125[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_93 = (*[93]byte)(b_125[32:])
	}

sz_93:
	{
		b := b_93[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_61 = (*[61]byte)(b_93[32:])
	}

sz_61:
	{
		b := b_61[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_29 = (*[29]byte)(b_61[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_29:
	h += n
	goto sz_29l

sz_124:
	{
		b := b_124[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_92 = (*[92]byte)(b_124[32:])
	}

sz_92:
	{
		b := b_92[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_60 = (*[60]byte)(b_92[32:])
	}

sz_60:
	{
		b := b_60[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_28 = (*[28]byte)(b_60[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_28:
	h += n
	goto sz_28l

sz_123:
	{
		b := b_123[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_91 = (*[91]byte)(b_123[32:])
	}

sz_91:
	{
		b := b_91[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_59 = (*[59]byte)(b_91[32:])
	}

sz_59:
	{
		b := b_59[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_27 = (*[27]byte)(b_59[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_27:
	h += n
	goto sz_27l

sz_122:
	{
		b := b_122[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_90 = (*[90]byte)(b_122[32:])
	}

sz_90:
	{
		b := b_90[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_58 = (*[58]byte)(b_90[32:])
	}

sz_58:
	{
		b := b_58[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_26 = (*[26]byte)(b_58[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_26:
	h += n
	goto sz_26l

sz_121:
	{
		b := b_121[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_89 = (*[89]byte)(b_121[32:])
	}

sz_89:
	{
		b := b_89[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_57 = (*[57]byte)(b_89[32:])
	}

sz_57:
	{
		b := b_57[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_25 = (*[25]byte)(b_57[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_25:
	h += n
	goto sz_25l

sz_120:
	{
		b := b_120[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_88 = (*[88]byte)(b_120[32:])
	}

sz_88:
	{
		b := b_88[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_56 = (*[56]byte)(b_88[32:])
	}

sz_56:
	{
		b := b_56[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_24 = (*[24]byte)(b_56[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_24:
	h += n
	goto sz_24l

sz_119:
	{
		b := b_119[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_87 = (*[87]byte)(b_119[32:])
	}

sz_87:
	{
		b := b_87[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_55 = (*[55]byte)(b_87[32:])
	}

sz_55:
	{
		b := b_55[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_23 = (*[23]byte)(b_55[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_23:
	h += n
	goto sz_23l

sz_118:
	{
		b := b_118[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_86 = (*[86]byte)(b_118[32:])
	}

sz_86:
	{
		b := b_86[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_54 = (*[54]byte)(b_86[32:])
	}

sz_54:
	{
		b := b_54[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_22 = (*[22]byte)(b_54[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_22:
	h += n
	goto sz_22l

sz_117:
	{
		b := b_117[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_85 = (*[85]byte)(b_117[32:])
	}

sz_85:
	{
		b := b_85[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_53 = (*[53]byte)(b_85[32:])
	}

sz_53:
	{
		b := b_53[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_21 = (*[21]byte)(b_53[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_21:
	h += n
	goto sz_21l

sz_116:
	{
		b := b_116[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_84 = (*[84]byte)(b_116[32:])
	}

sz_84:
	{
		b := b_84[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_52 = (*[52]byte)(b_84[32:])
	}

sz_52:
	{
		b := b_52[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_20 = (*[20]byte)(b_52[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_20:
	h += n
	goto sz_20l

sz_115:
	{
		b := b_115[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_83 = (*[83]byte)(b_115[32:])
	}

sz_83:
	{
		b := b_83[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_51 = (*[51]byte)(b_83[32:])
	}

sz_51:
	{
		b := b_51[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_19 = (*[19]byte)(b_51[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_19:
	h += n
	goto sz_19l

sz_114:
	{
		b := b_114[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_82 = (*[82]byte)(b_114[32:])
	}

sz_82:
	{
		b := b_82[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_50 = (*[50]byte)(b_82[32:])
	}

sz_50:
	{
		b := b_50[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_18 = (*[18]byte)(b_50[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_18:
	h += n
	goto sz_18l

sz_113:
	{
		b := b_113[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_81 = (*[81]byte)(b_113[32:])
	}

sz_81:
	{
		b := b_81[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_49 = (*[49]byte)(b_81[32:])
	}

sz_49:
	{
		b := b_49[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_17 = (*[17]byte)(b_49[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_17:
	h += n
	goto sz_17l

sz_112:
	{
		b := b_112[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_80 = (*[80]byte)(b_112[32:])
	}

sz_80:
	{
		b := b_80[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_48 = (*[48]byte)(b_80[32:])
	}

sz_48:
	{
		b := b_48[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_16 = (*[16]byte)(b_48[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_16:
	h += n
	goto sz_16l

sz_111:
	{
		b := b_111[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_79 = (*[79]byte)(b_111[32:])
	}

sz_79:
	{
		b := b_79[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_47 = (*[47]byte)(b_79[32:])
	}

sz_47:
	{
		b := b_47[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_15 = (*[15]byte)(b_47[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_15:
	h += n
	goto sz_15l

sz_110:
	{
		b := b_110[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_78 = (*[78]byte)(b_110[32:])
	}

sz_78:
	{
		b := b_78[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_46 = (*[46]byte)(b_78[32:])
	}

sz_46:
	{
		b := b_46[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_14 = (*[14]byte)(b_46[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_14:
	h += n
	goto sz_14l

sz_109:
	{
		b := b_109[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_77 = (*[77]byte)(b_109[32:])
	}

sz_77:
	{
		b := b_77[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_45 = (*[45]byte)(b_77[32:])
	}

sz_45:
	{
		b := b_45[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_13 = (*[13]byte)(b_45[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_13:
	h += n
	goto sz_13l

sz_108:
	{
		b := b_108[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_76 = (*[76]byte)(b_108[32:])
	}

sz_76:
	{
		b := b_76[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_44 = (*[44]byte)(b_76[32:])
	}

sz_44:
	{
		b := b_44[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_12 = (*[12]byte)(b_44[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_12:
	h += n
	goto sz_12l

sz_107:
	{
		b := b_107[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_75 = (*[75]byte)(b_107[32:])
	}

sz_75:
	{
		b := b_75[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_43 = (*[43]byte)(b_75[32:])
	}

sz_43:
	{
		b := b_43[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_11 = (*[11]byte)(b_43[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_11:
	h += n
	goto sz_11l

sz_106:
	{
		b := b_106[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_74 = (*[74]byte)(b_106[32:])
	}

sz_74:
	{
		b := b_74[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_42 = (*[42]byte)(b_74[32:])
	}

sz_42:
	{
		b := b_42[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_10 = (*[10]byte)(b_42[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_10:
	h += n
	goto sz_10l

sz_105:
	{
		b := b_105[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_73 = (*[73]byte)(b_105[32:])
	}

sz_73:
	{
		b := b_73[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_41 = (*[41]byte)(b_73[32:])
	}

sz_41:
	{
		b := b_41[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_9 = (*[9]byte)(b_41[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_9:
	h += n
	goto sz_9l

sz_104:
	{
		b := b_104[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_72 = (*[72]byte)(b_104[32:])
	}

sz_72:
	{
		b := b_72[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_40 = (*[40]byte)(b_72[32:])
	}

sz_40:
	{
		b := b_40[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_8 = (*[8]byte)(b_40[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_8:
	h += n
	goto sz_8l

sz_103:
	{
		b := b_103[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_71 = (*[71]byte)(b_103[32:])
	}

sz_71:
	{
		b := b_71[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_39 = (*[39]byte)(b_71[32:])
	}

sz_39:
	{
		b := b_39[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_7 = (*[7]byte)(b_39[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_7:
	h += n
	goto sz_7l

sz_102:
	{
		b := b_102[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_70 = (*[70]byte)(b_102[32:])
	}

sz_70:
	{
		b := b_70[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_38 = (*[38]byte)(b_70[32:])
	}

sz_38:
	{
		b := b_38[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_6 = (*[6]byte)(b_38[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_6:
	h += n
	goto sz_6l

sz_101:
	{
		b := b_101[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_69 = (*[69]byte)(b_101[32:])
	}

sz_69:
	{
		b := b_69[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_37 = (*[37]byte)(b_69[32:])
	}

sz_37:
	{
		b := b_37[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_5 = (*[5]byte)(b_37[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_5:
	h += n
	goto sz_5l

sz_100:
	{
		b := b_100[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_68 = (*[68]byte)(b_100[32:])
	}

sz_68:
	{
		b := b_68[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_36 = (*[36]byte)(b_68[32:])
	}

sz_36:
	{
		b := b_36[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_4 = (*[4]byte)(b_36[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_4:
	h += n
	goto sz_4l

sz_99:
	{
		b := b_99[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_67 = (*[67]byte)(b_99[32:])
	}

sz_67:
	{
		b := b_67[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_35 = (*[35]byte)(b_67[32:])
	}

sz_35:
	{
		b := b_35[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_3 = (*[3]byte)(b_35[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_3:
	h += n
	goto sz_3l

sz_98:
	{
		b := b_98[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_66 = (*[66]byte)(b_98[32:])
	}

sz_66:
	{
		b := b_66[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_34 = (*[34]byte)(b_66[32:])
	}

sz_34:
	{
		b := b_34[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_2 = (*[2]byte)(b_34[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_2:
	h += n
	goto sz_2l

sz_97:
	{
		b := b_97[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_65 = (*[65]byte)(b_97[32:])
	}

sz_65:
	{
		b := b_65[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_33 = (*[33]byte)(b_65[32:])
	}

sz_33:
	{
		b := b_33[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_1 = (*[1]byte)(b_33[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

sz_1:
	h += n
	goto sz_1l

sz_96:
	{
		b := b_96[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_64 = (*[64]byte)(b_96[32:])
	}

sz_64:
	{
		b := b_64[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_32 = (*[32]byte)(b_64[32:])
	}

sz_32:
	{
		b := b_32[:]
		var load uint64
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v1 += load * prime2
		v1 = bits.RotateLeft64(v1, 31)
		v1 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v2 += load * prime2
		v2 = bits.RotateLeft64(v2, 31)
		v2 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v3 += load * prime2
		v3 = bits.RotateLeft64(v3, 31)
		v3 *= prime1
		load = uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		b = b[8:]
		v4 += load * prime2
		v4 = bits.RotateLeft64(v4, 31)
		v4 *= prime1
		b_0 = (*[0]byte)(b_32[32:])
	}

	h = bits.RotateLeft64(v1, 1) + bits.RotateLeft64(v2, 7) + bits.RotateLeft64(v3, 12) + bits.RotateLeft64(v4, 18)
	{
		var temp uint64
		temp += v1 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v2 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v3 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}
	{
		var temp uint64
		temp += v4 * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = h*prime1 + prime4
	}

	h += n
	goto sz_0l

	// Theses are 8 bytes block trailing slides.
sz_31l:
	{
		b := b_31[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_23 = (*[23]byte)(b_31[8:])
	}

sz_23l:
	{
		b := b_23[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_15 = (*[15]byte)(b_23[8:])
	}

sz_15l:
	{
		b := b_15[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_7 = (*[7]byte)(b_15[8:])
	}

	goto sz_7l

sz_30l:
	{
		b := b_30[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_22 = (*[22]byte)(b_30[8:])
	}

sz_22l:
	{
		b := b_22[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_14 = (*[14]byte)(b_22[8:])
	}

sz_14l:
	{
		b := b_14[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_6 = (*[6]byte)(b_14[8:])
	}

	goto sz_6l

sz_29l:
	{
		b := b_29[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_21 = (*[21]byte)(b_29[8:])
	}

sz_21l:
	{
		b := b_21[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_13 = (*[13]byte)(b_21[8:])
	}

sz_13l:
	{
		b := b_13[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_5 = (*[5]byte)(b_13[8:])
	}

	goto sz_5l

sz_28l:
	{
		b := b_28[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_20 = (*[20]byte)(b_28[8:])
	}

sz_20l:
	{
		b := b_20[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_12 = (*[12]byte)(b_20[8:])
	}

sz_12l:
	{
		b := b_12[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_4 = (*[4]byte)(b_12[8:])
	}

	goto sz_4l

sz_27l:
	{
		b := b_27[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_19 = (*[19]byte)(b_27[8:])
	}

sz_19l:
	{
		b := b_19[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_11 = (*[11]byte)(b_19[8:])
	}

sz_11l:
	{
		b := b_11[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_3 = (*[3]byte)(b_11[8:])
	}

	goto sz_3l

sz_26l:
	{
		b := b_26[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_18 = (*[18]byte)(b_26[8:])
	}

sz_18l:
	{
		b := b_18[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_10 = (*[10]byte)(b_18[8:])
	}

sz_10l:
	{
		b := b_10[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_2 = (*[2]byte)(b_10[8:])
	}

	goto sz_2l

sz_25l:
	{
		b := b_25[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_17 = (*[17]byte)(b_25[8:])
	}

sz_17l:
	{
		b := b_17[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_9 = (*[9]byte)(b_17[8:])
	}

sz_9l:
	{
		b := b_9[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_1 = (*[1]byte)(b_9[8:])
	}

	goto sz_1l

sz_24l:
	{
		b := b_24[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_16 = (*[16]byte)(b_24[8:])
	}

sz_16l:
	{
		b := b_16[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_8 = (*[8]byte)(b_16[8:])
	}

sz_8l:
	{
		b := b_8[:]
		load := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56 // Work around for go.dev/issue/68081.
		var temp uint64
		temp += load * prime2
		temp = bits.RotateLeft64(temp, 31)
		temp *= prime1
		h ^= temp
		h = bits.RotateLeft64(h, 27)*prime1 + prime4
		b_0 = (*[0]byte)(b_8[8:])
	}

	goto sz_0l

	// Theses are the 4 bytes trailing slides.
sz_7l:
	{
		b := b_7[:]
		load := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24 // Work around for go.dev/issue/68081.
		h ^= uint64(load) * prime1
		h = bits.RotateLeft64(h, 23)*prime2 + prime3
		b_3 = (*[3]byte)(b_7[4:])
		goto sz_3l
	}

sz_6l:
	{
		b := b_6[:]
		load := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24 // Work around for go.dev/issue/68081.
		h ^= uint64(load) * prime1
		h = bits.RotateLeft64(h, 23)*prime2 + prime3
		b_2 = (*[2]byte)(b_6[4:])
		goto sz_2l
	}

sz_5l:
	{
		b := b_5[:]
		load := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24 // Work around for go.dev/issue/68081.
		h ^= uint64(load) * prime1
		h = bits.RotateLeft64(h, 23)*prime2 + prime3
		b_1 = (*[1]byte)(b_5[4:])
		goto sz_1l
	}

sz_4l:
	{
		b := b_4[:]
		load := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24 // Work around for go.dev/issue/68081.
		h ^= uint64(load) * prime1
		h = bits.RotateLeft64(h, 23)*prime2 + prime3
		b_0 = (*[0]byte)(b_4[4:])
		goto sz_0l
	}

	// This is the 1 bytes trailing slide.
sz_3l:
	h ^= uint64(b_3[0]) * prime5
	h = bits.RotateLeft64(h, 11) * prime1
	b_2 = (*[2]byte)(b_3[1:])

sz_2l:
	h ^= uint64(b_2[0]) * prime5
	h = bits.RotateLeft64(h, 11) * prime1
	b_1 = (*[1]byte)(b_2[1:])

sz_1l:
	h ^= uint64(b_1[0]) * prime5
	h = bits.RotateLeft64(h, 11) * prime1
	b_0 = (*[0]byte)(b_1[1:])

	// Finally the terminator.
sz_0l:
	_ = b_0 // this avoids a bunch of if i != 0 { in codegen and is optimized away.

	h ^= h >> 33
	h *= prime2
	h ^= h >> 29
	h *= prime3
	h ^= h >> 32

	return h
}
